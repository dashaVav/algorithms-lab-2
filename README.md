# AиСД Лабораторная работа №2
Даны прямоугольники на плоскости с углами в целочисленных координатах.  
Требуется как можно быстрее определять количество прямоугольников, покрывающих точку на плоскости, подготовка данных также должна занимать мало времени.
____
## Реализация трех алгоритмов 
____
### Алгоритм полного перебора
Не подразумевает специальную подготовку данных. Для каждой точки перебираются все прямоугольники.

```java
    public int search(Point point) {
        int count = 0;

        for (Rectangle rectangle : rectangles) {
            if (point.x >= rectangle.x1 && point.x <= rectangle.x2
                    && point.y >= rectangle.y1 && point.y <= rectangle.y2) {
                count++;
            }
        }

        return count;
    }
```

#### Сложность:
подготовка `O(1)`, поиск `O(N * M)`, где N - количество прямоугольников, M - количество точек.
____
### Алгоритм сжатия координат и построение карты

Подготовка данных происходит с помощью сжатия координат  всех угловых точек прямоугольников по осям х и y, создания и заполнения карты. Создание карты - это создание матрицы размерности `i х j`, где i - количество сжатых точек по оси х, j - количество сжатых точек по оси у. Заполнение карты - это обход всех прямоугольников и увеличение определенной проекции каждого прямоугольника на сжатых координатах на 1 в данной матрице.  
  
Поиск - запрос к матрице `map[i][j]`, где i - сжатая координата точки по х, j - сжатая координата точки по y. Сжатые координаты находятся с помощью бинарного поиска.
```java
 public int search(Point point) {
        int i = binSearch(point.x, zipX);
        int j = binSearch(point.y, zipY);
        if (i == -1 || j == -1) return 0;
        return map[i][j];
    }
```
#### Сложность:
подготовка `O(N^3)`, поиск `O(logN)`, где N - количество прямоугольников.
____
### Алгоритм сжатия координат и построения персистентного дерева отрезков 
Подготовка данных происходит с помощью построения персистентного дерева отрезков на сжатых координатах (создается PersistentSegmentTreeNodes, в котором хранятся корни деревьев).  
  
Поиск - получение нужного корня дерева по сжатым координатам точки и обход данного дерева.  
```java
    public int search(int x, int y){
        return searchInPersistentSegmentTree(PersistentSegmentTreeNodes.get(x), y);
    }

    private int searchInPersistentSegmentTree(Node root, int num) {
        if (root == null) return 0;

        int middle = (root.leftRange + root.rightRange) / 2;
        if (num < middle) {
            return root.sum + searchInPersistentSegmentTree(root.left, num);
        }
        else return root.sum + searchInPersistentSegmentTree(root.right, num);
    }
```
#### Сложность:
подготовка `O(NlogN)`, поиск `O(logN)`, где N - количество прямоугольников.
____
### Тестирование
#### Генерация прямоугольников
Набор вложенных друг в друга прямоугольников создается по формуле `{(10*i, 10*i), (10*(2N-i), 10*(2N-i))}`
```java
private static List<Rectangle> generateTestRectangles(int n){
        List<Rectangle> rectangles= new ArrayList<>();
        for (int i = 0; i < n; i++) {
            rectangles.add(new Rectangle(10 * i, 10 * i, 10 * (2 * n - 1), 10 * (2 * n - 1)));
        }
        return rectangles;
    }
```
#### Генерация точек:
Создается неслучайный набор распределенных равномерно по ненулевому пересечению прямоугольников, с помощью хэш функции `(p*i)^31%(20*N)` 
от i с разным базисом для x и y, p-большое простое, разное для x и y.
```java
    private static List<Point> generateTestPoints(int n){
        List<Point> points = new ArrayList<>();
        for (int i = 0; i < n; i++) {
            int x = (int) Math.pow(1009 * i, 31) % (20 * n);
            int y = (int) Math.pow(1013 * i, 31) % (20 * n);
            points.add(new Point(x, y));
        }
        return points;
    }
```
При запуске [main](https://github.com/dashaVav/algorithms_lab2/blob/master/src/main/java/tests/Autotest.java) используются сгенерированные тестовые данные. Результаты тестирования записываются в csv-файлы, для каждого алгоритма свой файл.

#### Данные для тестирования:
Количество прямоугольников = 2 ^ i, где 0 <= i <= 14  
Количество точек для каждого i = 100000  
Для посторения графиков используется [draw_graphs.py](https://github.com/dashaVav/algorithms_lab2/blob/master/artefacts/draw_graphs.py)
### Выводы
#### Изменение времени подготовки данных
![BuildTime.jpg](https://github.com/dashaVav/algorithms_lab2/blob/master/artefacts/BuildTime.jpg)  
   
На данном графике показана зависимость между количеством прямоугольников и временем подготовки данных. Алгоритм полного перебора затрачивает константно маленькое время(`O(N)`), так как не производит никаких манипуляций с данными. Алгоритм на карте и на дереве показывают примерно одинаковые результаты при маленьких данных, но при `N > 256` время работы алгоритма на карте начинает резко расти, так как в худшем случае приходится `N` раз пройтись по матрице `N х N`(`O(N^3)`). При тех же данных время алгоритма на дереве растет значительно медленнее(`O(NlogN)`).  

#### Изменение времени ответа на запрос    
![RequestTime.jpg](https://github.com/dashaVav/algorithms_lab2/blob/master/artefacts/RequestTime.jpg)  
  
На данном графике показана связь между количеством прямоугольников и временем ответа на запрос. Время алгоритма полного перебора стремительно растет с увеличением количества данных, так как ему приходится для каждой точки перебирать все прямоугольники(`О(n)`). В то время как другие два алгоритма, которые предполагают подготовку данных, относительно стабильный и растут очень медленно(`O(logN)`).

  
#### Изменение общего времени работы
![TotalTime.jpg](https://github.com/dashaVav/algorithms_lab2/blob/master/artefacts/TotalTime.jpg)  
  
График общего времени работы алгоритмов показывает, что алгоритм на карте при больших данных проигрывает двум другим за счет времени построения карты (`O(N^3)`). Наиболее эффективным является алгоритмы с использованием персистентного дерева отрезков, время его работы растет медленнее всех.


